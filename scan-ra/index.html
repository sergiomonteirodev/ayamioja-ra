<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
        html, body {
          margin: 0;
          padding: 0;
          height: 100%;
          overflow: hidden;
          background: transparent;
        }
        a-scene {
          position: absolute;
          top: 0;
          left: 0;
          height: 100%;
          width: 100%;
        }
        
        /* Esconder ícones do A-Frame */
        .a-enter-vr-button,
        .a-orientation-modal,
        .a-enter-vr-modal,
        .a-fullscreen-button,
        .a-fullscreen-modal,
        .a-fullscreen-overlay,
        .a-fullscreen-icon,
        [class*="fullscreen"],
        [class*="vr-button"],
        [class*="orientation"] {
          display: none !important;
          visibility: hidden !important;
          opacity: 0 !important;
          pointer-events: none !important;
        }
        .video-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1000;
        }
        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 20px;
          border-radius: 10px;
          text-align: center;
          font-family: Arial, sans-serif;
          max-width: 300px;
        }
        
        /* Modal de Scanning Personalizado */
        .scanning-overlay {
          background: linear-gradient(135deg, rgba(226, 106, 2, 0.9), rgba(91, 44, 9, 0.9));
          backdrop-filter: blur(10px);
        }
        
        .scanning-content {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 20px;
          padding: 40px;
          background: rgba(255, 255, 255, 0.1);
          border-radius: 20px;
          border: 2px solid rgba(255, 255, 255, 0.2);
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          max-width: 400px;
          text-align: center;
        }
        
        .scanning-icon {
          position: relative;
        }
        
        .scanning-circle {
          width: 80px;
          height: 80px;
          border: 3px solid rgba(255, 255, 255, 0.3);
          border-radius: 50%;
          position: relative;
          animation: pulse 2s ease-in-out infinite;
        }
        
        .scanning-dot {
          width: 12px;
          height: 12px;
          background: #e26a02;
          border-radius: 50%;
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          animation: scan 1.5s linear infinite;
        }
        
        .scanning-title {
          font-size: 24px;
          font-weight: 700;
          margin: 0;
          color: white;
          font-family: 'RooneySans', Arial, sans-serif;
        }
        
        .scanning-text {
          font-size: 16px;
          margin: 0;
          color: rgba(255, 255, 255, 0.9);
          line-height: 1.4;
          font-family: 'RooneySans', Arial, sans-serif;
        }
        
        .scanning-progress {
          width: 200px;
          height: 4px;
          background: rgba(255, 255, 255, 0.2);
          border-radius: 2px;
          overflow: hidden;
        }
        
        .progress-bar {
          width: 100%;
          height: 100%;
          background: rgba(255, 255, 255, 0.1);
          border-radius: 2px;
          position: relative;
        }
        
        .progress-fill {
          width: 0%;
          height: 100%;
          background: linear-gradient(90deg, #e26a02, #ff8c42);
          border-radius: 2px;
          animation: progress 3s ease-in-out infinite;
        }
        
        @keyframes pulse {
          0%, 100% {
            transform: scale(1);
            opacity: 1;
          }
          50% {
            transform: scale(1.1);
            opacity: 0.8;
          }
        }
        
        @keyframes scan {
          0% {
            transform: translate(-50%, -50%) rotate(0deg) translateX(30px) rotate(0deg);
          }
          100% {
            transform: translate(-50%, -50%) rotate(360deg) translateX(30px) rotate(-360deg);
          }
        }
        
        @keyframes progress {
          0% {
            width: 0%;
          }
          50% {
            width: 70%;
          }
          100% {
            width: 100%;
          }
        }
        
        /* Modal de Instruções Personalizado */
        .instructions-overlay {
          background: linear-gradient(135deg, rgba(226, 106, 2, 0.95), rgba(91, 44, 9, 0.95));
          backdrop-filter: blur(15px);
        }
        
        .instructions-content {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 25px;
          padding: 50px 40px;
          background: rgba(255, 255, 255, 0.15);
          border-radius: 25px;
          border: 3px solid rgba(255, 255, 255, 0.3);
          box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
          max-width: 450px;
          text-align: center;
          position: relative;
          overflow: hidden;
        }
        
        .instructions-content::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: 4px;
          background: linear-gradient(90deg, #e26a02, #ff8c42, #e26a02);
          animation: shimmer 3s ease-in-out infinite;
        }
        
        .instructions-icon {
          position: relative;
        }
        
        .target-icon {
          font-size: 60px;
          animation: bounce 2s ease-in-out infinite;
          filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }
        
        .instructions-title {
          font-size: 32px;
          font-weight: 700;
          margin: 0;
          color: white;
          font-family: 'RooneySans', Arial, sans-serif;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
          letter-spacing: 1px;
        }
        
        .instructions-text {
          font-size: 18px;
          margin: 0;
          color: rgba(255, 255, 255, 0.95);
          line-height: 1.5;
          font-family: 'RooneySans', Arial, sans-serif;
          font-weight: 500;
        }
        
        .instructions-subtext {
          font-size: 16px;
          margin: 0;
          color: rgba(255, 255, 255, 0.8);
          line-height: 1.4;
          font-family: 'RooneySans', Arial, sans-serif;
          font-weight: 400;
        }
        
        .test-video-button {
          display: flex;
          align-items: center;
          gap: 12px;
          padding: 15px 30px;
          background: linear-gradient(135deg, #007bff, #0056b3);
          color: white;
          border: none;
          border-radius: 15px;
          cursor: pointer;
          font-size: 16px;
          font-weight: 600;
          font-family: 'RooneySans', Arial, sans-serif;
          transition: all 0.3s ease;
          box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
          position: relative;
          overflow: hidden;
        }
        
        .test-video-button::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
          transition: left 0.5s ease;
        }
        
        .test-video-button:hover::before {
          left: 100%;
        }
        
        .test-video-button:hover {
          transform: translateY(-2px);
          box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
          background: linear-gradient(135deg, #0056b3, #004085);
        }
        
        .test-video-button:active {
          transform: translateY(0);
        }
        
        .button-icon {
          font-size: 18px;
        }
        
        .button-text {
          font-size: 16px;
        }
        
        @keyframes bounce {
          0%, 20%, 50%, 80%, 100% {
            transform: translateY(0);
          }
          40% {
            transform: translateY(-10px);
          }
          60% {
            transform: translateY(-5px);
          }
        }
        
        @keyframes shimmer {
          0% {
            transform: translateX(-100%);
          }
          100% {
            transform: translateX(100%);
          }
        }
        .target-info {
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 10px;
          border-radius: 5px;
          font-family: Arial, sans-serif;
          font-size: 14px;
        }
        
        /* Toggle Controls - Mesmo estilo da página principal */
        .toggle-controls {
          position: absolute;
          top: 120px;
          left: 0;
          right: 0;
          z-index: 999;
          display: flex;
          justify-content: space-between;
          padding: 0 30px;
        }

        .toggle-label {
          display: flex;
          align-items: center;
          gap: 10px;
          background-color: rgb(255, 255, 255);
          padding: 8px 15px;
          border-radius: 25px;
          color: #e26a02;
          font-weight: 600;
          cursor: pointer;
          font-family: 'RooneySans', Arial, sans-serif;
        }

        .toggle-label:hover {
          background-color: rgba(255, 255, 255, 0.9);
        }

        .toggle-input {
          display: none !important;
        }

        .toggle-slider {
          width: 50px;
          height: 24px;
          background-color: #ccc;
          border-radius: 12px;
          position: relative;
          transition: background-color 0.3s;
        }

        .toggle-slider::before {
          content: '';
          position: absolute;
          width: 20px;
          height: 20px;
          border-radius: 50%;
          background-color: white;
          top: 2px;
          left: 2px;
          transition: transform 0.3s;
        }

        .toggle-input:checked + .toggle-slider {
          background-color: #5b2c09;
        }

        .toggle-input:checked + .toggle-slider::before {
          transform: translateX(26px);
        }

        .toggle-text {
          font-size: 25px;
        }

        .toggle-icon {
          width: 45px;
          height: 45px;
          object-fit: contain;
        }
        
        /* Responsive para mobile */
       @media (max-width: 1024px) {
         .toggle-controls {
           top: 100px;
           flex-direction: row;
           justify-content: space-around;
           padding: 0 15px;
         }

         .toggle-label {
           font-size: 12px;
           padding: 6px 12px;
           gap: 8px;
         }

         .toggle-slider {
           width: 40px;
           height: 20px;
         }

         .toggle-slider::before {
           width: 16px;
           height: 16px;
         }

         .toggle-input:checked + .toggle-slider::before {
           transform: translateX(20px);
         }

         .toggle-text {
           font-size: 18px;
         }

         .toggle-icon {
           width: 35px;
           height: 35px;
         }
         
         /* Responsivo para vídeo de libras */
         .interpreter-container {
           width: 250px;
           height: 250px;
           bottom: 20px;
           left: 20px;
         }
       }

        @media (max-width: 768px) {
          .toggle-controls {
            top: 90px;
            padding: 0 10px;
          }

          .toggle-label {
            font-size: 10px;
            padding: 4px 8px;
            gap: 6px;
          }

          .toggle-slider {
            width: 35px;
            height: 18px;
          }

          .toggle-slider::before {
            width: 14px;
            height: 14px;
          }

          .toggle-input:checked + .toggle-slider::before {
            transform: translateX(17px);
          }

          .toggle-text {
            font-size: 14px;
          }

          .toggle-icon {
            width: 30px;
            height: 30px;
          }
          
          /* Responsivo para vídeo de libras */
          .interpreter-container {
            width: 200px;
            height: 200px;
            bottom: 20px;
            left: 20px;
          }
        }

        @media (max-width: 600px) {
          .toggle-controls {
            top: 100px;
            padding: 0 8px;
          }

          .toggle-label {
            font-size: 9px;
            padding: 3px 6px;
            gap: 4px;
          }

          .toggle-slider {
            width: 30px;
            height: 16px;
          }

          .toggle-slider::before {
            width: 12px;
            height: 12px;
          }

          .toggle-input:checked + .toggle-slider::before {
            transform: translateX(14px);
          }

          .toggle-text {
            font-size: 12px;
          }

          .toggle-icon {
            width: 25px;
            height: 25px;
          }
          
          /* Responsivo para vídeo de libras */
          .interpreter-container {
            width: 180px;
            height: 180px;
            bottom: 15px;
            left: 15px;
          }
        }
        
        /* Botão Voltar */
        .back-button-container {
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 999;
        }
        
        .back-button {
          display: block;
          text-decoration: none;
          color: inherit;
        }
        
        .back-button-image {
          width: 150px;
          height: 150px;
          object-fit: contain;
          transition: all 0.3s ease;
          cursor: pointer;
        }
        
        .back-button-image:hover {
          transform: scale(1.1);
        }
        
        /* Responsivo para botão voltar */
        @media (max-width: 1024px) {
          .back-button-container {
            bottom: 15px;
            right: 15px;
          }
          
          .back-button-image {
            width: 120px;
            height: 120px;
          }
        }
        
        @media (max-width: 768px) {
          .back-button-container {
            bottom: 15px;
            right: 15px;
          }
          
          .back-button-image {
            width: 100px;
            height: 100px;
          }
        }
        
        @media (max-width: 600px) {
          .back-button-container {
            bottom: 10px;
            right: 10px;
          }
          
          .back-button-image {
            width: 80px;
            height: 80px;
          }
        }
        
        @media (max-width: 480px) {
          .back-button-container {
            bottom: 10px;
            right: 10px;
          }
          
          .back-button-image {
            width: 70px;
            height: 70px;
          }
        }
        
        @media (max-width: 360px) {
          .back-button-container {
            bottom: 8px;
            right: 8px;
          }
          
          .back-button-image {
            width: 60px;
            height: 60px;
          }
        }
        
        /* Responsividade para 320px (menor tela) */
        @media (max-width: 320px) {
          /* Toggle Controls */
          .toggle-controls {
            top: 80px;
            padding: 0 5px;
            gap: 5px;
          }

          .toggle-label {
            font-size: 8px;
            padding: 2px 4px;
            gap: 3px;
            border-radius: 15px;
          }

          .toggle-slider {
            width: 28px;
            height: 14px;
            border-radius: 7px;
          }

          .toggle-slider::before {
            width: 10px;
            height: 10px;
          }

          .toggle-input:checked + .toggle-slider::before {
            transform: translateX(14px);
          }

          .toggle-text {
            font-size: 10px;
          }

          .toggle-icon {
            width: 20px;
            height: 20px;
          }
          
          /* Vídeo de Libras */
          .interpreter-container {
            width: 140px !important;
            height: 140px !important;
            bottom: 10px !important;
            left: 10px !important;
            border-width: 2px !important;
          }
          
          .interpreter-video {
            border-radius: 10px !important;
          }
          
          /* Botão Voltar */
          .back-button-container {
            bottom: 5px;
            right: 5px;
          }
          
          .back-button-image {
            width: 50px;
            height: 50px;
          }
          
          /* Modal de Instruções */
          .instructions-content {
            padding: 30px 20px;
            max-width: 280px;
            gap: 15px;
            border-radius: 15px;
          }
          
          .target-icon {
            font-size: 40px;
          }
          
          .instructions-title {
            font-size: 22px;
          }
          
          .instructions-text {
            font-size: 14px;
          }
          
          .instructions-subtext {
            font-size: 12px;
          }
          
          .test-video-button {
            padding: 10px 20px;
            font-size: 12px;
            border-radius: 10px;
            gap: 8px;
          }
          
          .button-icon {
            font-size: 14px;
          }
          
          .button-text {
            font-size: 12px;
          }
          
          /* Modal de Scanning */
          .scanning-content {
            padding: 30px 20px;
            max-width: 280px;
            gap: 15px;
          }
          
          .scanning-icon {
            width: 60px;
            height: 60px;
          }
          
          .scanning-circle {
            width: 60px;
            height: 60px;
            border-width: 3px;
          }
          
          .scanning-dot {
            width: 6px;
            height: 6px;
          }
          
          .scanning-title {
            font-size: 18px;
          }
          
          .scanning-text {
            font-size: 13px;
          }
          
          .progress-bar {
            height: 6px;
          }
          
          /* Video Overlay */
          .video-overlay {
            padding: 10px;
          }
          
          /* Target Info */
          .target-info {
            top: 10px;
            left: 10px;
            padding: 6px 10px;
            font-size: 11px;
            border-radius: 10px;
          }
        }
    </style>
  </head>
  <body>
    <!-- Toggle Controls -->
    <div class="toggle-controls">
        <div class="toggle-left">
            <label class="toggle-label">
                <img src="../libras.png" alt="Libras" class="toggle-icon">
                <input type="checkbox" id="libras-toggle" class="toggle-input">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-right">
            <label class="toggle-label">
                <input type="checkbox" id="audio-toggle" class="toggle-input">
                <span class="toggle-slider"></span>
                <img src="../ad.png" alt="áudio descrição" class="toggle-icon">
            </label>
        </div>
    </div>
    
    <!-- Botão Voltar -->
    <div class="back-button-container">
        <a href="../index.html" class="back-button">
            <img src="../voltar_botao.png" alt="Voltar" class="back-button-image">
        </a>
    </div>

    <a-scene
      mindar-image="imageTargetSrc: ./targets/targets(13).mind; maxTrack: 3; uiScanning: #ui-scanning; uiLoading: #ui-loading; filterMinCF: 0.0001; filterBeta: 0.1; missTolerance: 15; warmupTolerance: 3; autoStart: true; showStats: false;"
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights: true, antialias: false, precision: mediump"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      embedded
      ui="enabled: false"
    >
      <a-assets>
        <!-- Vídeo para Target 0 -->
        <video
          id="video1"
          src="assets/ayo_teste.mp4?v=2"
          preload="auto"
          loop
          crossorigin="anonymous"
          webkit-playsinline
          playsinline
          muted
        ></video>
        
        <!-- Vídeo para Target 1 (mesmo vídeo por enquanto) -->
        <video
          id="video2"
          src="assets/ayo_teste.mp4?v=2"
          preload="auto"
          loop
          crossorigin="anonymous"
          webkit-playsinline
          playsinline
          muted
        ></video>
        
        <!-- Vídeo para Target 2 (mesmo vídeo por enquanto) -->
        <video
          id="video3"
          src="assets/anim_2.mp4?v=3"
          preload="auto"
          loop
          crossorigin="anonymous"
          webkit-playsinline
          playsinline
        ></video>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Target 0 - Primeiro vídeo -->
      <a-entity mindar-image-target="targetIndex: 0" id="target0">
        <a-plane
          id="videoPlane0"
          width="1"
          height="1"
          position="0 0.1 0.1"
          material="shader: flat; src: #video1"
          pose-smoother="positionFactor: 0.25; rotationFactor: 0.25; scaleFactor: 0.25"
          visible="false"
        ></a-plane>
      </a-entity>

      <!-- Target 1 - Segundo vídeo -->
      <a-entity mindar-image-target="targetIndex: 1" id="target1">
        <a-plane
          id="videoPlane1"
          width="1"
          height="1"
          position="0 0.1 0.1"
          material="shader: flat; src: #video2"
          pose-smoother="positionFactor: 0.25; rotationFactor: 0.25; scaleFactor: 0.25"
          visible="false"
        ></a-plane>
      </a-entity>

      <!-- Target 2 - Terceiro vídeo -->
      <a-entity mindar-image-target="targetIndex: 2" id="target2">
        <a-plane
          id="videoPlane2"
          width="1"
          height="1"
          position="0 0 0.005"
          material="shader: flat; src: #video3"
          pose-smoother="positionFactor: 0.25; rotationFactor: 0.25; scaleFactor: 0.25"
          visible="false"
        ></a-plane>
      </a-entity>
    </a-scene>

    <!-- Overlays de UI (loading, scanning e instruções) -->
    <div class="video-container">
      <!-- UI de Loading (pode trocar o conteúdo por um GIF) -->
      <div id="ui-loading" class="video-overlay" style="display: none; background: rgba(0,0,0,0.6);">
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <div style="width:18px; height:18px; border:3px solid #fff; border-top-color: transparent; border-radius:50%; animation: spin 1s linear infinite;"></div>
          <span>Carregando…</span>
        </div>
      </div>

      <!-- UI de Scanning Personalizada -->
      <div id="ui-scanning" class="video-overlay scanning-overlay" style="display: none;">
        <div class="scanning-content">
          <div class="scanning-icon">
            <div class="scanning-circle">
              <div class="scanning-dot"></div>
            </div>
          </div>
          <h3 class="scanning-title">Escaneando Target</h3>
          <p class="scanning-text">Aponte a câmera para o marcador para ativar o vídeo</p>
          <div class="scanning-progress">
            <div class="progress-bar">
              <div class="progress-fill"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="video-overlay instructions-overlay" id="instructions">
        <div class="instructions-content">
          <div class="instructions-icon">
            <div class="target-icon">🎯</div>
          </div>
          <h3 class="instructions-title">AYÀ MI O JÁ</h3>
          <p class="instructions-text">Aponte a câmera para os targets para ver os vídeos</p>
          <p class="instructions-subtext">Clique na tela para ativar</p>
          <button id="testVideo" class="test-video-button">
            <span class="button-icon">🎥</span>
            <span class="button-text">Testar Vídeo</span>
          </button>
        </div>
      </div>
      <div class="target-info" id="targetInfo" style="display: none;">
        <div id="targetStatus">Nenhum target detectado</div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // CSS simples para animação do loading
        const styleSpin = document.createElement('style');
        styleSpin.innerHTML = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
        document.head.appendChild(styleSpin);

        // Componente de suavização de pose para reduzir tremor
        if (!AFRAME.components['pose-smoother']) {
          AFRAME.registerComponent('pose-smoother', {
            schema: {
              positionFactor: { type: 'number', default: 0.2 },
              rotationFactor: { type: 'number', default: 0.2 },
              scaleFactor: { type: 'number', default: 0.2 }
            },
            init() {
              this.lastPosition = new THREE.Vector3();
              this.lastQuaternion = new THREE.Quaternion();
              this.lastScale = new THREE.Vector3(1, 1, 1);
              this.hasLast = false;
            },
            tick() {
              const obj = this.el.object3D;
              if (!obj) return;
              if (!this.hasLast) {
                this.lastPosition.copy(obj.position);
                this.lastQuaternion.copy(obj.quaternion);
                this.lastScale.copy(obj.scale);
                this.hasLast = true;
                return;
              }
              // Interpolação linear para posição e escala
              this.lastPosition.lerp(obj.position, this.data.positionFactor);
              this.lastScale.lerp(obj.scale, this.data.scaleFactor);
              // Slerp para rotação
              this.lastQuaternion.slerp(obj.quaternion, this.data.rotationFactor);
              obj.position.copy(this.lastPosition);
              obj.scale.copy(this.lastScale);
              obj.quaternion.copy(this.lastQuaternion);
            }
          });
        }

        // Referências aos elementos
        const videos = [
          document.querySelector("#video1"),
          document.querySelector("#video2"),
          document.querySelector("#video3")
        ];
        
        const videoPlanes = [
          document.querySelector("#videoPlane0"),
          document.querySelector("#videoPlane1"),
          document.querySelector("#videoPlane2")
        ];

        // Ajustar tamanho dos planos conforme o aspect ratio do vídeo e target
        const applyVideoAspectToPlane = (video, plane, targetIndex = 0) => {
          const setRatio = () => {
            if (!video.videoWidth || !video.videoHeight) return;
            const videoRatio = video.videoWidth / video.videoHeight;
            
            // Para o video3 (target 2), redimensionar para o tamanho do livro/target
            if (targetIndex === 2) {
              // Tamanho mais próximo ao livro real (ajustado para melhor centralização)
              const bookWidth = 1.05;  // Largura do target em unidades A-Frame (ajuste fino)
              const bookHeight = 1.40; // Altura do target em unidades A-Frame (ajuste fino)
              
              // Calcular dimensões mantendo o aspect ratio do vídeo
              let width, height;
              if (videoRatio > bookWidth / bookHeight) {
                // Vídeo é mais largo que o livro - ajustar pela largura
                width = bookWidth;
                height = bookWidth / videoRatio;
              } else {
                // Vídeo é mais alto que o livro - ajustar pela altura
                height = bookHeight;
                width = bookHeight * videoRatio;
              }
              
              plane.setAttribute('width', width.toFixed(3));
              plane.setAttribute('height', height.toFixed(3));
              console.log(`📚 Plane ${plane.id} redimensionado para livro: ${width.toFixed(3)} x ${height.toFixed(3)} (ratio ${videoRatio.toFixed(3)})`);
            } else {
              // Para outros vídeos, usar proporção padrão
              const height = 1;
              const width = videoRatio * height;
              plane.setAttribute('width', width.toFixed(3));
              plane.setAttribute('height', height.toFixed(3));
              console.log(`📐 Plane ${plane.id} ajustado: ${width.toFixed(3)} x ${height.toFixed(3)} (ratio ${videoRatio.toFixed(3)})`);
            }
          };
          if (video.readyState >= 1) {
            setRatio();
          } else {
            video.addEventListener('loadedmetadata', setRatio, { once: true });
          }
        };
        
        const targets = [
          document.querySelector("#target0"),
          document.querySelector("#target1"),
          document.querySelector("#target2")
        ];

        const instructions = document.querySelector("#instructions");
        const targetInfo = document.querySelector("#targetInfo");
        const targetStatus = document.querySelector("#targetStatus");
        const testVideoBtn = document.querySelector("#testVideo");

        // Detectar se é Android/Chrome para aplicar otimizações específicas
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isChrome = /Chrome/i.test(navigator.userAgent) && !/Edge|Edg/i.test(navigator.userAgent);
        const isMobile = /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent);
        const isLowPowerDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
        
        console.log("📱 Dispositivo detectado:", {
          isAndroid,
          isChrome,
          isMobile,
          isLowPowerDevice,
          cores: navigator.hardwareConcurrency,
          memoria: navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'desconhecido',
          userAgent: navigator.userAgent.substring(0, 80) + '...'
        });

        // Verificar disponibilidade do arquivo de vídeo e aplicar fallback se necessário
        const FALLBACK_SRC = 'assets/ayo_teste.mp4?v=2';
        const ensureVideoSourceAvailable = async (video) => {
          try {
            const src = video.getAttribute('src') || video.src;
            if (!src) throw new Error('src vazio');
            const response = await fetch(src, { method: 'HEAD', cache: 'no-store' });
            if (!response.ok) {
              console.warn(`⚠️ ${src} retornou ${response.status}. Usando fallback ${FALLBACK_SRC}`);
              video.setAttribute('src', FALLBACK_SRC);
            }
          } catch (e) {
            console.warn(`⚠️ Falha ao verificar vídeo (${video.id}). Usando fallback ${FALLBACK_SRC}`, e);
            video.setAttribute('src', FALLBACK_SRC);
          }
        };

        // Pré-carregar vídeos de forma agressiva (especialmente para Android)
        const preloadVideos = () => {
          videos.forEach((video, index) => {
            if (!video) return;
            
            // Forçar atributos inline para Android
            video.setAttribute('playsinline', '');
            video.setAttribute('webkit-playsinline', '');
            video.playsInline = true;
            
            // Mutar todos exceto video3
            if (video.id !== 'video3') {
              video.muted = true;
            }
            
            // Forçar load() para iniciar download
            if (video.readyState === 0) {
              console.log(`🔄 Pré-carregando vídeo ${video.id}...`);
              try {
                video.load();
              } catch(e) {
                console.warn(`⚠️ Erro ao pré-carregar ${video.id}:`, e);
              }
            }
            
            // Adicionar listeners para monitorar progresso
            video.addEventListener('loadeddata', () => {
              console.log(`✅ ${video.id} carregado (readyState: ${video.readyState})`);
            }, { once: true });
            
            video.addEventListener('error', (e) => {
              console.error(`❌ Erro ao carregar ${video.id}:`, e, video.error);
            }, { once: true });
          });
        };

        // Função para ativar vídeo com retry específico para Android
        const enableVideo = (video, retryCount = 0) => {
          console.log(`🎥 Tentando reproduzir vídeo: ${video.id} (tentativa ${retryCount + 1})`);
          
          // Garantir configurações inline
          try {
            video.setAttribute && video.setAttribute('playsinline', '');
            video.setAttribute && video.setAttribute('webkit-playsinline', '');
          } catch {}
          video.playsInline = true;
          
          // Só mutar se não for o video3 (que deve ter áudio)
          if (video.id !== 'video3') {
            video.muted = true;
          }
          
          // Para Android: sempre forçar load() antes de play()
          const mustLoad = isAndroid || video.readyState === 0 || video.networkState === 3;
          if (mustLoad) {
            console.log(`📦 Chamando load() no vídeo: ${video.id} (readyState: ${video.readyState}, networkState: ${video.networkState})`);
            try { 
              video.load(); 
            } catch(e) { 
              console.warn("load() falhou", e); 
            }
          }
          
          // Tenta tocar com retry
          const tryPlay = () => {
            return video.play().then(() => {
              console.log(`✅ Vídeo reproduzindo: ${video.id} (readyState: ${video.readyState})`);
              return true;
            }).catch((e) => {
              console.warn(`❌ Erro ao reproduzir vídeo: ${video.id}`, e);
              
              // Retry para Android (até 3 tentativas)
              if (isAndroid && retryCount < 3) {
                console.log(`🔄 Tentando novamente em 500ms... (retry ${retryCount + 1}/3)`);
                setTimeout(() => {
                  enableVideo(video, retryCount + 1);
                }, 500);
              }
              return false;
            });
          };
          
          if (video.readyState < 2) { // < HAVE_CURRENT_DATA
            const canplayOnce = () => {
              video.removeEventListener('canplay', canplayOnce);
              tryPlay();
            };
            video.addEventListener('canplay', canplayOnce, {once: true});
            // fallback timeout aumentado para Android
            setTimeout(tryPlay, isAndroid ? 2500 : 1500);
          } else {
            tryPlay();
          }
        };

        // Função para pausar vídeo
        const pauseVideo = (video) => {
          video.pause();
        };

        // Função para atualizar status
        const updateTargetStatus = (activeTargets) => {
          if (activeTargets.length > 0) {
            targetInfo.style.display = "block";
            targetStatus.textContent = `Targets ativos: ${activeTargets.join(", ")}`;
          } else {
            targetInfo.style.display = "none";
          }
        };

        // Array para rastrear targets ativos
        let activeTargets = [];

        // Pré-carregar vídeos logo após a inicialização
        console.log("🚀 Iniciando pré-carregamento de vídeos...");
        preloadVideos();

        // Primeira interação do usuário
        let userInteracted = false;
        document.body.addEventListener("click", async () => {
          if (userInteracted) return;
          userInteracted = true;
          
          instructions.style.display = "none";
          console.log("👆 Primeira interação do usuário detectada");
          
          for (const video of videos) {
            await ensureVideoSourceAvailable(video);
            // Força load antes do play para evitar NS_BINDING_ABORTED
            try { 
              if (video.readyState === 0) {
                video.load(); 
              }
            } catch(e) {
              console.warn(`⚠️ Erro ao carregar ${video.id}:`, e);
            }
            // Só mutar se não for o video3 (que deve ter áudio)
            if (video.id !== 'video3') {
              video.muted = true;
            }
            // Para evitar áudio antes do target: só toca video3 quando o target 2 for encontrado
            if (video.id !== 'video3') {
              enableVideo(video);
            }
          }
        }, { once: true });
        
        // Botão de teste de vídeo
        testVideoBtn.addEventListener("click", async () => {
          console.log("🧪 Testando reprodução de vídeo...");
          const firstVideo = videos[0];
          const firstPlane = videoPlanes[0];

          console.log("🎥 Forçando reprodução do vídeo:", firstVideo.id);
          await ensureVideoSourceAvailable(firstVideo);
          enableVideo(firstVideo);

          const showWhenReady = () => {
            console.log("📺 Exibindo plane após canplay:", firstPlane.id);
            firstPlane.setAttribute("visible", "true");
          };
          if (firstVideo.readyState >= 2) {
            showWhenReady();
          } else {
            firstVideo.addEventListener('canplay', function once() {
              firstVideo.removeEventListener('canplay', once);
              showWhenReady();
            });
          }
          
          // Mostrar status
          targetInfo.style.display = "block";
          targetStatus.textContent = "Teste de vídeo ativo";
        });

        // Event listeners para cada target
        targets.forEach((target, index) => {
          const video = videos[index];
          const videoPlane = videoPlanes[index];

          // Aplicar proporção do vídeo ao plane
          applyVideoAspectToPlane(video, videoPlane, index);

          // Quando o target é encontrado
          target.addEventListener("targetFound", async () => {
            console.log(`🎯 Target ${index} encontrado`);
            console.log("🎥 Habilitando vídeo:", video.id);
            // Se ainda não carregou, garante load e play
            if (video.readyState === 0) {
              try { video.load(); } catch {}
            }
            await ensureVideoSourceAvailable(video);
            // Para o video3, garantir áudio só aqui
            if (video.id === 'video3') {
              try { video.muted = false; } catch {}
            }
            enableVideo(video);

            // Só exibe o plane quando o vídeo tiver dados para evitar frame preto
            const revealPlane = () => {
              console.log("📺 Exibindo plane após canplay:", videoPlane.id);
              videoPlane.setAttribute("visible", "true");
            };
            if (video.readyState >= 2) {
              revealPlane();
            } else {
              const once = () => { video.removeEventListener('canplay', once); revealPlane(); };
              video.addEventListener('canplay', once);
            }
            
            // Adicionar à lista de targets ativos
            if (!activeTargets.includes(index)) {
              activeTargets.push(index);
              updateTargetStatus(activeTargets);
            }
          });

          // Quando o target é perdido
          target.addEventListener("targetLost", () => {
            console.log(`❌ Target ${index} perdido`);
            videoPlane.setAttribute("visible", "false");
            pauseVideo(video);
            
            // Para Android: resetar vídeo para liberar memória
            if (isAndroid && isLowPowerDevice) {
              setTimeout(() => {
                if (video.paused) {
                  video.currentTime = 0;
                  console.log(`🧹 Resetando ${video.id} para liberar memória`);
                }
              }, 1000);
            }
            
            // Remover da lista de targets ativos
            activeTargets = activeTargets.filter(t => t !== index);
            updateTargetStatus(activeTargets);
          });
        });

        // Controle de visibilidade do overlay
        let hasFoundTarget = false;
        targets.forEach(target => {
        target.addEventListener("targetFound", () => {
            if (!hasFoundTarget) {
              hasFoundTarget = true;
              instructions.style.display = "none";
            }
          });
        });

        // Log de inicialização
        console.log("🚀 MindAR Multi-Targets inicializado");
        console.log("🎯 Targets configurados:", targets.length);
        console.log("🎥 Vídeos configurados:", videos.length);
        console.log("📁 Arquivo .mind:", "./targets/targets(13).mind");
        
        // Verificar se os elementos foram encontrados
        targets.forEach((target, index) => {
          console.log(`Target ${index}:`, target ? "✅ Encontrado" : "❌ Não encontrado");
        });
        
        videos.forEach((video, index) => {
          console.log(`Vídeo ${index}:`, video ? "✅ Encontrado" : "❌ Não encontrado");
          if (video) {
            console.log(`  - src: ${video.src}`);
            console.log(`  - readyState: ${video.readyState}`);
          }
        });
        
        videoPlanes.forEach((plane, index) => {
          console.log(`Plane ${index}:`, plane ? "✅ Encontrado" : "❌ Não encontrado");
        });
        
        // Aguardar o MindAR estar pronto
        const scene = document.querySelector('a-scene');
        scene.addEventListener('renderstart', () => {
          console.log("🎬 MindAR renderizado e pronto!");
        });
        
        // Verificar se há erros no carregamento do .mind
        scene.addEventListener('error', (e) => {
          console.error("❌ Erro no MindAR:", e);
        });
        
        // Gerenciar visibilidade da página (Android frequentemente suspende apps)
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            console.log("📴 Página oculta - pausando vídeos");
            videos.forEach(video => {
              if (!video.paused) {
                pauseVideo(video);
              }
            });
          } else {
            console.log("📱 Página visível novamente");
            // Recarregar vídeos ativos se necessário
            if (isAndroid) {
              activeTargets.forEach(index => {
                const video = videos[index];
                if (video && video.paused && video.readyState > 0) {
                  console.log(`🔄 Retomando vídeo ${video.id}`);
                  enableVideo(video);
                }
              });
            }
          }
        });
        
        // Para Android: gerenciar eventos de pausa/resume
        if (isAndroid) {
          window.addEventListener('pagehide', () => {
            console.log("📴 App entrando em background");
            videos.forEach(video => pauseVideo(video));
          });
          
          window.addEventListener('pageshow', (event) => {
            console.log("📱 App retornando ao foreground");
            if (event.persisted) {
              console.log("🔄 Página restaurada do cache - recarregando vídeos");
              preloadVideos();
            }
          });
        }
        
        // Toggle Controls
        const librasToggle = document.getElementById('libras-toggle');
        const audioToggle = document.getElementById('audio-toggle');
        
        // Iniciar com toggle de libras ativado
        librasToggle.checked = true;
        
        // Criar containers para vídeos de libras (um para cada vídeo AR)
        const interpreterContainers = [];
        const interpreterVideos = [];
        
        // Criar 3 containers de vídeo de libras (um para cada vídeo AR)
        for (let i = 0; i < 3; i++) {
          const interpreterContainer = document.createElement('div');
          interpreterContainer.id = `interpreter-video-${i}`;
          interpreterContainer.className = 'interpreter-container';
          interpreterContainer.style.cssText = `
            position: absolute;
            bottom: 72px;
            left: 20px;
            width: 300px;
            height: 300px;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            border-radius: 15px;
            overflow: hidden;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
          `;
          
          // Criar vídeo de libras específico para cada target
          const interpreterVideo = document.createElement('video');
          interpreterVideo.id = `interpreter-${i}`;
          interpreterVideo.className = 'interpreter-video';
          interpreterVideo.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
          `;
          interpreterVideo.src = '../anim_ayo.mp4';
          interpreterVideo.muted = true;
          interpreterVideo.volume = 0;
          interpreterVideo.loop = false;
          interpreterVideo.playsinline = true;
          interpreterVideo.webkitPlaysinline = true;
          
          interpreterContainer.appendChild(interpreterVideo);
          document.body.appendChild(interpreterContainer);
          
          interpreterContainers.push(interpreterContainer);
          interpreterVideos.push(interpreterVideo);
        }
        
        // Variável para controlar se algum target está ativo
        let activeTargetIndex = -1;
        
        // Libras toggle - controla visibilidade dos vídeos de libras
        librasToggle.addEventListener('change', () => {
          console.log('Libras toggle:', librasToggle.checked);
          if (librasToggle.checked) {
            // Só mostrar vídeo de libras se algum target estiver ativo
            if (activeTargetIndex !== -1) {
              showActiveInterpreter(activeTargetIndex);
            }
          } else {
            // Esconder todos os containers de intérprete
            interpreterContainers.forEach(container => {
              container.style.opacity = '0';
              setTimeout(() => {
                container.style.display = 'none';
              }, 300);
            });
          }
        });
        
        // Simular evento de change para aplicar o estado inicial
        librasToggle.dispatchEvent(new Event('change'));
        
        // Audio toggle - controla áudio descrição
        audioToggle.addEventListener('change', () => {
          console.log('Audio toggle:', audioToggle.checked);
          // Aqui você pode adicionar lógica para áudio descrição se necessário
        });
        
        // Sincronizar vídeo de libras específico com seu vídeo AR correspondente
        function syncInterpreterWithAR(videoIndex) {
          const arVideo = videos[videoIndex];
          const interpreterVideo = interpreterVideos[videoIndex];
          const interpreterContainer = interpreterContainers[videoIndex];
          
          if (arVideo && interpreterVideo && librasToggle.checked && arVideo.readyState >= 3) {
            // Sincronizar tempo apenas se o vídeo AR estiver pronto
            interpreterVideo.currentTime = arVideo.currentTime;
            
            // Se o vídeo AR está tocando, o de libras correspondente também deve tocar
            if (!arVideo.paused && interpreterVideo.paused) {
              interpreterVideo.play().catch(e => console.log(`Erro ao reproduzir vídeo de libras ${videoIndex}:`, e));
            }
            // Se o vídeo AR está pausado, o de libras correspondente também deve pausar
            else if (arVideo.paused && !interpreterVideo.paused) {
              interpreterVideo.pause();
            }
          }
        }
        
        // Função para iniciar vídeo de libras automaticamente
        function startInterpreterVideo(videoIndex) {
          const interpreterVideo = interpreterVideos[videoIndex];
          const arVideo = videos[videoIndex];
          
          if (interpreterVideo && librasToggle.checked && arVideo && !arVideo.paused) {
            // Só iniciar se o vídeo AR estiver tocando e pronto para reproduzir
            if (arVideo.readyState >= 3) { // HAVE_FUTURE_DATA ou superior
              interpreterVideo.currentTime = arVideo.currentTime;
              
              // Garantir que o vídeo de libras está carregado
              if (interpreterVideo.readyState >= 2) {
                interpreterVideo.play().catch(e => console.log(`Erro ao iniciar vídeo de libras ${videoIndex}:`, e));
              } else {
                // Aguardar o vídeo de libras carregar
                interpreterVideo.addEventListener('canplay', () => {
                  interpreterVideo.currentTime = arVideo.currentTime;
                  interpreterVideo.play().catch(e => console.log(`Erro ao iniciar vídeo de libras ${videoIndex}:`, e));
                }, { once: true });
              }
            } else {
              // Aguardar o vídeo AR estar pronto
              arVideo.addEventListener('canplay', () => {
                interpreterVideo.currentTime = arVideo.currentTime;
                if (interpreterVideo.readyState >= 2) {
                  interpreterVideo.play().catch(e => console.log(`Erro ao iniciar vídeo de libras ${videoIndex}:`, e));
                } else {
                  interpreterVideo.addEventListener('canplay', () => {
                    interpreterVideo.currentTime = arVideo.currentTime;
                    interpreterVideo.play().catch(e => console.log(`Erro ao iniciar vídeo de libras ${videoIndex}:`, e));
                  }, { once: true });
                }
              }, { once: true });
            }
          }
        }
        
        // Função para mostrar apenas o vídeo de libras do target ativo
        function showActiveInterpreter(activeIndex) {
          const arVideo = videos[activeIndex];
          
          // Só mostrar se o vídeo AR estiver tocando e pronto para reproduzir
          if (arVideo && !arVideo.paused && arVideo.readyState >= 3 && librasToggle.checked) {
            interpreterContainers.forEach((container, index) => {
              if (index === activeIndex) {
                container.style.display = 'block';
                container.style.opacity = '1';
              } else {
                container.style.opacity = '0';
                setTimeout(() => {
                  if (index !== activeIndex) {
                    container.style.display = 'none';
                  }
                }, 300);
              }
            });
          }
        }
        
        // Monitorar mudanças nos vídeos AR individuais
        videos.forEach((video, index) => {
          video.addEventListener('play', () => {
            console.log(`Vídeo AR ${index} iniciado`);
            activeTargetIndex = index; // Marcar target como ativo
            if (librasToggle.checked) {
              showActiveInterpreter(index);
              startInterpreterVideo(index); // Iniciar vídeo de libras automaticamente
            }
            syncInterpreterWithAR(index);
          });
          
          video.addEventListener('pause', () => {
            console.log(`Vídeo AR ${index} pausado`);
            // Esconder vídeo de libras quando AR pausa
            if (librasToggle.checked) {
              interpreterContainers[index].style.opacity = '0';
              setTimeout(() => {
                interpreterContainers[index].style.display = 'none';
              }, 300);
            }
            syncInterpreterWithAR(index);
          });
          
          
          video.addEventListener('timeupdate', () => {
            syncInterpreterWithAR(index);
          });
          
          video.addEventListener('seeked', () => {
            syncInterpreterWithAR(index);
          });
          
          video.addEventListener('ended', () => {
            console.log(`Vídeo AR ${index} finalizado`);
            activeTargetIndex = -1; // Marcar que nenhum target está ativo
            syncInterpreterWithAR(index);
            // Pausar e esconder o container de libras correspondente
            interpreterVideos[index].pause();
            interpreterContainers[index].style.opacity = '0';
            setTimeout(() => {
              interpreterContainers[index].style.display = 'none';
            }, 300);
          });
        });
      });
    </script>
  </body>
</html>
