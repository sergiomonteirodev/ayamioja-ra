<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
        html, body {
          margin: 0;
          padding: 0;
          height: 100%;
          overflow: hidden;
          background: transparent;
        }
        a-scene {
          position: absolute;
          top: 0;
          left: 0;
          height: 100%;
          width: 100%;
        }
        .video-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1000;
        }
        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 20px;
          border-radius: 10px;
          text-align: center;
          font-family: Arial, sans-serif;
          max-width: 300px;
        }
        .target-info {
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 10px;
          border-radius: 5px;
          font-family: Arial, sans-serif;
          font-size: 14px;
        }
        
        /* Toggle Controls - Mesmo estilo da p√°gina principal */
        .toggle-controls {
          position: absolute;
          top: 120px;
          left: 0;
          right: 0;
          z-index: 999;
          display: flex;
          justify-content: space-between;
          padding: 0 30px;
        }

        .toggle-label {
          display: flex;
          align-items: center;
          gap: 10px;
          background-color: rgb(255, 255, 255);
          padding: 8px 15px;
          border-radius: 25px;
          color: #e26a02;
          font-weight: 600;
          cursor: pointer;
          font-family: 'RooneySans', Arial, sans-serif;
        }

        .toggle-label:hover {
          background-color: rgba(255, 255, 255, 0.9);
        }

        .toggle-input {
          display: none !important;
        }

        .toggle-slider {
          width: 50px;
          height: 24px;
          background-color: #ccc;
          border-radius: 12px;
          position: relative;
          transition: background-color 0.3s;
        }

        .toggle-slider::before {
          content: '';
          position: absolute;
          width: 20px;
          height: 20px;
          border-radius: 50%;
          background-color: white;
          top: 2px;
          left: 2px;
          transition: transform 0.3s;
        }

        .toggle-input:checked + .toggle-slider {
          background-color: #5b2c09;
        }

        .toggle-input:checked + .toggle-slider::before {
          transform: translateX(26px);
        }

        .toggle-text {
          font-size: 25px;
        }

        .toggle-icon {
          width: 45px;
          height: 45px;
          object-fit: contain;
        }
        
        /* Responsive para mobile */
       @media (max-width: 1024px) {
         .toggle-controls {
           top: 100px;
           flex-direction: row;
           justify-content: space-around;
           padding: 0 15px;
         }

         .toggle-label {
           font-size: 12px;
           padding: 6px 12px;
           gap: 8px;
         }

         .toggle-slider {
           width: 40px;
           height: 20px;
         }

         .toggle-slider::before {
           width: 16px;
           height: 16px;
         }

         .toggle-input:checked + .toggle-slider::before {
           transform: translateX(20px);
         }

         .toggle-text {
           font-size: 18px;
         }

         .toggle-icon {
           width: 35px;
           height: 35px;
         }
         
         /* Responsivo para v√≠deo de libras */
         .interpreter-container {
           width: 250px;
           height: 250px;
           bottom: 20px;
           left: 20px;
         }
       }

        @media (max-width: 768px) {
          .toggle-controls {
            top: 90px;
            padding: 0 10px;
          }

          .toggle-label {
            font-size: 10px;
            padding: 4px 8px;
            gap: 6px;
          }

          .toggle-slider {
            width: 35px;
            height: 18px;
          }

          .toggle-slider::before {
            width: 14px;
            height: 14px;
          }

          .toggle-input:checked + .toggle-slider::before {
            transform: translateX(17px);
          }

          .toggle-text {
            font-size: 14px;
          }

          .toggle-icon {
            width: 30px;
            height: 30px;
          }
          
          /* Responsivo para v√≠deo de libras */
          .interpreter-container {
            width: 200px;
            height: 200px;
            bottom: 20px;
            left: 20px;
          }
        }

        @media (max-width: 600px) {
          .toggle-controls {
            top: 100px;
            padding: 0 8px;
          }

          .toggle-label {
            font-size: 9px;
            padding: 3px 6px;
            gap: 4px;
          }

          .toggle-slider {
            width: 30px;
            height: 16px;
          }

          .toggle-slider::before {
            width: 12px;
            height: 12px;
          }

          .toggle-input:checked + .toggle-slider::before {
            transform: translateX(14px);
          }

          .toggle-text {
            font-size: 12px;
          }

          .toggle-icon {
            width: 25px;
            height: 25px;
          }
          
          /* Responsivo para v√≠deo de libras */
          .interpreter-container {
            width: 180px;
            height: 180px;
            bottom: 15px;
            left: 15px;
          }
        }
        
        /* Bot√£o Voltar */
        .back-button-container {
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 999;
        }
        
        .back-button {
          display: block;
          text-decoration: none;
          color: inherit;
        }
        
        .back-button-image {
          width: 150px;
          height: 150px;
          object-fit: contain;
          transition: all 0.3s ease;
          cursor: pointer;
        }
        
        .back-button-image:hover {
          transform: scale(1.1);
        }
        
        /* Responsivo para bot√£o voltar */
        @media (max-width: 1024px) {
          .back-button-container {
            bottom: 15px;
            right: 15px;
          }
          
          .back-button-image {
            width: 120px;
            height: 120px;
          }
        }
        
        @media (max-width: 768px) {
          .back-button-container {
            bottom: 15px;
            right: 15px;
          }
          
          .back-button-image {
            width: 100px;
            height: 100px;
          }
        }
        
        @media (max-width: 600px) {
          .back-button-container {
            bottom: 10px;
            right: 10px;
          }
          
          .back-button-image {
            width: 80px;
            height: 80px;
          }
        }
        
        @media (max-width: 480px) {
          .back-button-container {
            bottom: 10px;
            right: 10px;
          }
          
          .back-button-image {
            width: 70px;
            height: 70px;
          }
        }
        
        @media (max-width: 360px) {
          .back-button-container {
            bottom: 8px;
            right: 8px;
          }
          
          .back-button-image {
            width: 60px;
            height: 60px;
          }
        }
    </style>
  </head>
  <body>
    <!-- Toggle Controls -->
    <div class="toggle-controls">
        <div class="toggle-left">
            <label class="toggle-label">
                <img src="../libras.png" alt="Libras" class="toggle-icon">
                <input type="checkbox" id="libras-toggle" class="toggle-input">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-right">
            <label class="toggle-label">
                <input type="checkbox" id="audio-toggle" class="toggle-input">
                <span class="toggle-slider"></span>
                <img src="../ad.png" alt="√°udio descri√ß√£o" class="toggle-icon">
            </label>
        </div>
    </div>
    
    <!-- Bot√£o Voltar -->
    <div class="back-button-container">
        <a href="../index.html" class="back-button">
            <img src="../voltar_botao.png" alt="Voltar" class="back-button-image">
        </a>
    </div>

    <a-scene
      mindar-image="imageTargetSrc: ./targets/targets(13).mind; maxTrack: 3; uiScanning: #ui-scanning; uiLoading: #ui-loading; filterMinCF: 0.0001; filterBeta: 0.05; missTolerance: 10; warmupTolerance: 5;"
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      embedded
      ui="enabled: false"
    >
      <a-assets>
        <!-- V√≠deo para Target 0 -->
        <video
          id="video1"
          src="assets/ayo_teste.mp4?v=2"
          preload="auto"
          loop
          crossorigin="anonymous"
          webkit-playsinline
          playsinline
          muted
        ></video>
        
        <!-- V√≠deo para Target 1 (mesmo v√≠deo por enquanto) -->
        <video
          id="video2"
          src="assets/ayo_teste.mp4?v=2"
          preload="auto"
          loop
          crossorigin="anonymous"
          webkit-playsinline
          playsinline
          muted
        ></video>
        
        <!-- V√≠deo para Target 2 (mesmo v√≠deo por enquanto) -->
        <video
          id="video3"
          src="assets/anim_2.mp4?v=3"
          preload="auto"
          loop
          crossorigin="anonymous"
          webkit-playsinline
          playsinline
        ></video>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Target 0 - Primeiro v√≠deo -->
      <a-entity mindar-image-target="targetIndex: 0" id="target0">
        <a-plane
          id="videoPlane0"
          width="1"
          height="1"
          position="0 0.1 0.1"
          material="shader: flat; src: #video1"
          pose-smoother="positionFactor: 0.25; rotationFactor: 0.25; scaleFactor: 0.25"
          visible="false"
        ></a-plane>
      </a-entity>

      <!-- Target 1 - Segundo v√≠deo -->
      <a-entity mindar-image-target="targetIndex: 1" id="target1">
        <a-plane
          id="videoPlane1"
          width="1"
          height="1"
          position="0 0.1 0.1"
          material="shader: flat; src: #video2"
          pose-smoother="positionFactor: 0.25; rotationFactor: 0.25; scaleFactor: 0.25"
          visible="false"
        ></a-plane>
      </a-entity>

      <!-- Target 2 - Terceiro v√≠deo -->
      <a-entity mindar-image-target="targetIndex: 2" id="target2">
        <a-plane
          id="videoPlane2"
          width="1"
          height="1"
          position="0 0 0.005"
          material="shader: flat; src: #video3"
          pose-smoother="positionFactor: 0.25; rotationFactor: 0.25; scaleFactor: 0.25"
          visible="false"
        ></a-plane>
      </a-entity>
    </a-scene>

    <!-- Overlays de UI (loading, scanning e instru√ß√µes) -->
    <div class="video-container">
      <!-- UI de Loading (pode trocar o conte√∫do por um GIF) -->
      <div id="ui-loading" class="video-overlay" style="display: none; background: rgba(0,0,0,0.6);">
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <div style="width:18px; height:18px; border:3px solid #fff; border-top-color: transparent; border-radius:50%; animation: spin 1s linear infinite;"></div>
          <span>Carregando‚Ä¶</span>
        </div>
      </div>

      <!-- UI de Scanning (pode trocar por arte pr√≥pria) -->
      <div id="ui-scanning" class="video-overlay" style="display: none; background: rgba(0,0,0,0.6);">
        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
          <span>Escaneando‚Ä¶ aponte a c√¢mera para o marcador</span>
          <div style="width:120px; height:120px; border:2px dashed rgba(255,255,255,0.8); border-radius:8px;"></div>
        </div>
      </div>

      <div class="video-overlay" id="instructions">
        <h3>üéØ MindAR Multi-Targets</h3>
        <p>Apontar a c√¢mera para os targets para ver os v√≠deos</p>
        <p>Clique na tela para ativar</p>
        <button id="testVideo" style="margin-top: 10px; padding: 10px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
          üé• Testar V√≠deo
        </button>
      </div>
      <div class="target-info" id="targetInfo" style="display: none;">
        <div id="targetStatus">Nenhum target detectado</div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // CSS simples para anima√ß√£o do loading
        const styleSpin = document.createElement('style');
        styleSpin.innerHTML = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
        document.head.appendChild(styleSpin);

        // Componente de suaviza√ß√£o de pose para reduzir tremor
        if (!AFRAME.components['pose-smoother']) {
          AFRAME.registerComponent('pose-smoother', {
            schema: {
              positionFactor: { type: 'number', default: 0.2 },
              rotationFactor: { type: 'number', default: 0.2 },
              scaleFactor: { type: 'number', default: 0.2 }
            },
            init() {
              this.lastPosition = new THREE.Vector3();
              this.lastQuaternion = new THREE.Quaternion();
              this.lastScale = new THREE.Vector3(1, 1, 1);
              this.hasLast = false;
            },
            tick() {
              const obj = this.el.object3D;
              if (!obj) return;
              if (!this.hasLast) {
                this.lastPosition.copy(obj.position);
                this.lastQuaternion.copy(obj.quaternion);
                this.lastScale.copy(obj.scale);
                this.hasLast = true;
                return;
              }
              // Interpola√ß√£o linear para posi√ß√£o e escala
              this.lastPosition.lerp(obj.position, this.data.positionFactor);
              this.lastScale.lerp(obj.scale, this.data.scaleFactor);
              // Slerp para rota√ß√£o
              this.lastQuaternion.slerp(obj.quaternion, this.data.rotationFactor);
              obj.position.copy(this.lastPosition);
              obj.scale.copy(this.lastScale);
              obj.quaternion.copy(this.lastQuaternion);
            }
          });
        }

        // Refer√™ncias aos elementos
        const videos = [
          document.querySelector("#video1"),
          document.querySelector("#video2"),
          document.querySelector("#video3")
        ];
        
        const videoPlanes = [
          document.querySelector("#videoPlane0"),
          document.querySelector("#videoPlane1"),
          document.querySelector("#videoPlane2")
        ];

        // Ajustar tamanho dos planos conforme o aspect ratio do v√≠deo e target
        const applyVideoAspectToPlane = (video, plane, targetIndex = 0) => {
          const setRatio = () => {
            if (!video.videoWidth || !video.videoHeight) return;
            const videoRatio = video.videoWidth / video.videoHeight;
            
            // Para o video3 (target 2), redimensionar para o tamanho do livro/target
            if (targetIndex === 2) {
              // Tamanho mais pr√≥ximo ao livro real (ajustado para melhor centraliza√ß√£o)
              const bookWidth = 1.05;  // Largura do target em unidades A-Frame (ajuste fino)
              const bookHeight = 1.40; // Altura do target em unidades A-Frame (ajuste fino)
              
              // Calcular dimens√µes mantendo o aspect ratio do v√≠deo
              let width, height;
              if (videoRatio > bookWidth / bookHeight) {
                // V√≠deo √© mais largo que o livro - ajustar pela largura
                width = bookWidth;
                height = bookWidth / videoRatio;
              } else {
                // V√≠deo √© mais alto que o livro - ajustar pela altura
                height = bookHeight;
                width = bookHeight * videoRatio;
              }
              
              plane.setAttribute('width', width.toFixed(3));
              plane.setAttribute('height', height.toFixed(3));
              console.log(`üìö Plane ${plane.id} redimensionado para livro: ${width.toFixed(3)} x ${height.toFixed(3)} (ratio ${videoRatio.toFixed(3)})`);
            } else {
              // Para outros v√≠deos, usar propor√ß√£o padr√£o
              const height = 1;
              const width = videoRatio * height;
              plane.setAttribute('width', width.toFixed(3));
              plane.setAttribute('height', height.toFixed(3));
              console.log(`üìê Plane ${plane.id} ajustado: ${width.toFixed(3)} x ${height.toFixed(3)} (ratio ${videoRatio.toFixed(3)})`);
            }
          };
          if (video.readyState >= 1) {
            setRatio();
          } else {
            video.addEventListener('loadedmetadata', setRatio, { once: true });
          }
        };
        
        const targets = [
          document.querySelector("#target0"),
          document.querySelector("#target1"),
          document.querySelector("#target2")
        ];

        const instructions = document.querySelector("#instructions");
        const targetInfo = document.querySelector("#targetInfo");
        const targetStatus = document.querySelector("#targetStatus");
        const testVideoBtn = document.querySelector("#testVideo");

        // Verificar disponibilidade do arquivo de v√≠deo e aplicar fallback se necess√°rio
        const FALLBACK_SRC = 'assets/ayo_teste.mp4?v=2';
        const ensureVideoSourceAvailable = async (video) => {
          try {
            const src = video.getAttribute('src') || video.src;
            if (!src) throw new Error('src vazio');
            const response = await fetch(src, { method: 'HEAD', cache: 'no-store' });
            if (!response.ok) {
              console.warn(`‚ö†Ô∏è ${src} retornou ${response.status}. Usando fallback ${FALLBACK_SRC}`);
              video.setAttribute('src', FALLBACK_SRC);
            }
          } catch (e) {
            console.warn(`‚ö†Ô∏è Falha ao verificar v√≠deo (${video.id}). Usando fallback ${FALLBACK_SRC}`, e);
            video.setAttribute('src', FALLBACK_SRC);
          }
        };

        // Fun√ß√£o para ativar v√≠deo
        const enableVideo = (video) => {
          console.log("üé• Tentando reproduzir v√≠deo:", video.id);
          try {
            video.setAttribute && video.setAttribute('playsinline', '');
            video.setAttribute && video.setAttribute('webkit-playsinline', '');
          } catch {}
          video.playsInline = true;
          // S√≥ mutar se n√£o for o video3 (que deve ter √°udio)
          if (video.id !== 'video3') {
            video.muted = true;
          }
          // Se nunca carregou ou houve aborto, for√ßa load()
          const mustLoad = video.readyState === 0 || video.networkState === 3; // NETWORK_NO_SOURCE
          if (mustLoad) {
            console.log("üì¶ Chamando load() no v√≠deo:", video.id, {readyState: video.readyState, networkState: video.networkState});
            try { video.load(); } catch(e) { console.warn("load() falhou", e); }
          }
          // Tenta tocar
          const tryPlay = () => video.play().then(() => {
            console.log("‚úÖ V√≠deo reproduzindo:", video.id, {readyState: video.readyState});
          }).catch((e) => {
            console.warn("‚ùå Erro ao reproduzir v√≠deo:", video.id, e);
          });
          if (video.readyState < 2) { // < HAVE_CURRENT_DATA
            const canplayOnce = () => {
              video.removeEventListener('canplay', canplayOnce);
              tryPlay();
            };
            video.addEventListener('canplay', canplayOnce, {once: true});
            // fallback timeout
            setTimeout(tryPlay, 1500);
          } else {
            tryPlay();
          }
        };

        // Fun√ß√£o para pausar v√≠deo
        const pauseVideo = (video) => {
          video.pause();
        };

        // Fun√ß√£o para atualizar status
        const updateTargetStatus = (activeTargets) => {
          if (activeTargets.length > 0) {
            targetInfo.style.display = "block";
            targetStatus.textContent = `Targets ativos: ${activeTargets.join(", ")}`;
          } else {
            targetInfo.style.display = "none";
          }
        };

        // Array para rastrear targets ativos
        let activeTargets = [];

        // Primeira intera√ß√£o do usu√°rio
        document.body.addEventListener("click", async () => {
          instructions.style.display = "none";
          for (const video of videos) {
            await ensureVideoSourceAvailable(video);
            // For√ßa load antes do play para evitar NS_BINDING_ABORTED
            try { video.load(); } catch {}
            // S√≥ mutar se n√£o for o video3 (que deve ter √°udio)
            if (video.id !== 'video3') {
              video.muted = true;
            }
            // Para evitar √°udio antes do target: s√≥ toca video3 quando o target 2 for encontrado
            if (video.id !== 'video3') {
              enableVideo(video);
            }
          }
        });
        
        // Bot√£o de teste de v√≠deo
        testVideoBtn.addEventListener("click", async () => {
          console.log("üß™ Testando reprodu√ß√£o de v√≠deo...");
          const firstVideo = videos[0];
          const firstPlane = videoPlanes[0];

          console.log("üé• For√ßando reprodu√ß√£o do v√≠deo:", firstVideo.id);
          await ensureVideoSourceAvailable(firstVideo);
          enableVideo(firstVideo);

          const showWhenReady = () => {
            console.log("üì∫ Exibindo plane ap√≥s canplay:", firstPlane.id);
            firstPlane.setAttribute("visible", "true");
          };
          if (firstVideo.readyState >= 2) {
            showWhenReady();
          } else {
            firstVideo.addEventListener('canplay', function once() {
              firstVideo.removeEventListener('canplay', once);
              showWhenReady();
            });
          }
          
          // Mostrar status
          targetInfo.style.display = "block";
          targetStatus.textContent = "Teste de v√≠deo ativo";
        });

        // Event listeners para cada target
        targets.forEach((target, index) => {
          const video = videos[index];
          const videoPlane = videoPlanes[index];

          // Aplicar propor√ß√£o do v√≠deo ao plane
          applyVideoAspectToPlane(video, videoPlane, index);

          // Quando o target √© encontrado
          target.addEventListener("targetFound", async () => {
            console.log(`üéØ Target ${index} encontrado`);
            console.log("üé• Habilitando v√≠deo:", video.id);
            // Se ainda n√£o carregou, garante load e play
            if (video.readyState === 0) {
              try { video.load(); } catch {}
            }
            await ensureVideoSourceAvailable(video);
            // Para o video3, garantir √°udio s√≥ aqui
            if (video.id === 'video3') {
              try { video.muted = false; } catch {}
            }
            enableVideo(video);

            // S√≥ exibe o plane quando o v√≠deo tiver dados para evitar frame preto
            const revealPlane = () => {
              console.log("üì∫ Exibindo plane ap√≥s canplay:", videoPlane.id);
              videoPlane.setAttribute("visible", "true");
            };
            if (video.readyState >= 2) {
              revealPlane();
            } else {
              const once = () => { video.removeEventListener('canplay', once); revealPlane(); };
              video.addEventListener('canplay', once);
            }
            
            // Adicionar √† lista de targets ativos
            if (!activeTargets.includes(index)) {
              activeTargets.push(index);
              updateTargetStatus(activeTargets);
            }
          });

          // Quando o target √© perdido
          target.addEventListener("targetLost", () => {
            console.log(`‚ùå Target ${index} perdido`);
            videoPlane.setAttribute("visible", "false");
            pauseVideo(video);
            
            // Remover da lista de targets ativos
            activeTargets = activeTargets.filter(t => t !== index);
            updateTargetStatus(activeTargets);
          });
        });

        // Controle de visibilidade do overlay
        let hasFoundTarget = false;
        targets.forEach(target => {
        target.addEventListener("targetFound", () => {
            if (!hasFoundTarget) {
              hasFoundTarget = true;
              instructions.style.display = "none";
            }
          });
        });

        // Log de inicializa√ß√£o
        console.log("üöÄ MindAR Multi-Targets inicializado");
        console.log("üéØ Targets configurados:", targets.length);
        console.log("üé• V√≠deos configurados:", videos.length);
        console.log("üìÅ Arquivo .mind:", "./targets/targets(13).mind");
        
        // Verificar se os elementos foram encontrados
        targets.forEach((target, index) => {
          console.log(`Target ${index}:`, target ? "‚úÖ Encontrado" : "‚ùå N√£o encontrado");
        });
        
        videos.forEach((video, index) => {
          console.log(`V√≠deo ${index}:`, video ? "‚úÖ Encontrado" : "‚ùå N√£o encontrado");
          if (video) {
            console.log(`  - src: ${video.src}`);
            console.log(`  - readyState: ${video.readyState}`);
          }
        });
        
        videoPlanes.forEach((plane, index) => {
          console.log(`Plane ${index}:`, plane ? "‚úÖ Encontrado" : "‚ùå N√£o encontrado");
        });
        
        // Aguardar o MindAR estar pronto
        const scene = document.querySelector('a-scene');
        scene.addEventListener('renderstart', () => {
          console.log("üé¨ MindAR renderizado e pronto!");
        });
        
        // Verificar se h√° erros no carregamento do .mind
        scene.addEventListener('error', (e) => {
          console.error("‚ùå Erro no MindAR:", e);
        });
        
        // Toggle Controls
        const librasToggle = document.getElementById('libras-toggle');
        const audioToggle = document.getElementById('audio-toggle');
        
        // Iniciar com toggle de libras ativado
        librasToggle.checked = true;
        
        // Criar containers para v√≠deos de libras (um para cada v√≠deo AR)
        const interpreterContainers = [];
        const interpreterVideos = [];
        
        // Criar 3 containers de v√≠deo de libras (um para cada v√≠deo AR)
        for (let i = 0; i < 3; i++) {
          const interpreterContainer = document.createElement('div');
          interpreterContainer.id = `interpreter-video-${i}`;
          interpreterContainer.className = 'interpreter-container';
          interpreterContainer.style.cssText = `
            position: absolute;
            bottom: 72px;
            left: 20px;
            width: 300px;
            height: 300px;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            border-radius: 15px;
            overflow: hidden;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
          `;
          
          // Criar v√≠deo de libras espec√≠fico para cada target
          const interpreterVideo = document.createElement('video');
          interpreterVideo.id = `interpreter-${i}`;
          interpreterVideo.className = 'interpreter-video';
          interpreterVideo.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
          `;
          interpreterVideo.src = '../anim_ayo.mp4';
          interpreterVideo.muted = true;
          interpreterVideo.volume = 0;
          interpreterVideo.loop = false;
          interpreterVideo.playsinline = true;
          interpreterVideo.webkitPlaysinline = true;
          
          interpreterContainer.appendChild(interpreterVideo);
          document.body.appendChild(interpreterContainer);
          
          interpreterContainers.push(interpreterContainer);
          interpreterVideos.push(interpreterVideo);
        }
        
        // Vari√°vel para controlar se algum target est√° ativo
        let activeTargetIndex = -1;
        
        // Libras toggle - controla visibilidade dos v√≠deos de libras
        librasToggle.addEventListener('change', () => {
          console.log('Libras toggle:', librasToggle.checked);
          if (librasToggle.checked) {
            // S√≥ mostrar v√≠deo de libras se algum target estiver ativo
            if (activeTargetIndex !== -1) {
              showActiveInterpreter(activeTargetIndex);
            }
          } else {
            // Esconder todos os containers de int√©rprete
            interpreterContainers.forEach(container => {
              container.style.opacity = '0';
              setTimeout(() => {
                container.style.display = 'none';
              }, 300);
            });
          }
        });
        
        // Simular evento de change para aplicar o estado inicial
        librasToggle.dispatchEvent(new Event('change'));
        
        // Audio toggle - controla √°udio descri√ß√£o
        audioToggle.addEventListener('change', () => {
          console.log('Audio toggle:', audioToggle.checked);
          // Aqui voc√™ pode adicionar l√≥gica para √°udio descri√ß√£o se necess√°rio
        });
        
        // Sincronizar v√≠deo de libras espec√≠fico com seu v√≠deo AR correspondente
        function syncInterpreterWithAR(videoIndex) {
          const arVideo = videos[videoIndex];
          const interpreterVideo = interpreterVideos[videoIndex];
          const interpreterContainer = interpreterContainers[videoIndex];
          
          if (arVideo && interpreterVideo && librasToggle.checked && arVideo.readyState >= 3) {
            // Sincronizar tempo apenas se o v√≠deo AR estiver pronto
            interpreterVideo.currentTime = arVideo.currentTime;
            
            // Se o v√≠deo AR est√° tocando, o de libras correspondente tamb√©m deve tocar
            if (!arVideo.paused && interpreterVideo.paused) {
              interpreterVideo.play().catch(e => console.log(`Erro ao reproduzir v√≠deo de libras ${videoIndex}:`, e));
            }
            // Se o v√≠deo AR est√° pausado, o de libras correspondente tamb√©m deve pausar
            else if (arVideo.paused && !interpreterVideo.paused) {
              interpreterVideo.pause();
            }
          }
        }
        
        // Fun√ß√£o para iniciar v√≠deo de libras automaticamente
        function startInterpreterVideo(videoIndex) {
          const interpreterVideo = interpreterVideos[videoIndex];
          const arVideo = videos[videoIndex];
          
          if (interpreterVideo && librasToggle.checked && arVideo && !arVideo.paused) {
            // S√≥ iniciar se o v√≠deo AR estiver tocando e pronto para reproduzir
            if (arVideo.readyState >= 3) { // HAVE_FUTURE_DATA ou superior
              interpreterVideo.currentTime = arVideo.currentTime;
              
              // Garantir que o v√≠deo de libras est√° carregado
              if (interpreterVideo.readyState >= 2) {
                interpreterVideo.play().catch(e => console.log(`Erro ao iniciar v√≠deo de libras ${videoIndex}:`, e));
              } else {
                // Aguardar o v√≠deo de libras carregar
                interpreterVideo.addEventListener('canplay', () => {
                  interpreterVideo.currentTime = arVideo.currentTime;
                  interpreterVideo.play().catch(e => console.log(`Erro ao iniciar v√≠deo de libras ${videoIndex}:`, e));
                }, { once: true });
              }
            } else {
              // Aguardar o v√≠deo AR estar pronto
              arVideo.addEventListener('canplay', () => {
                interpreterVideo.currentTime = arVideo.currentTime;
                if (interpreterVideo.readyState >= 2) {
                  interpreterVideo.play().catch(e => console.log(`Erro ao iniciar v√≠deo de libras ${videoIndex}:`, e));
                } else {
                  interpreterVideo.addEventListener('canplay', () => {
                    interpreterVideo.currentTime = arVideo.currentTime;
                    interpreterVideo.play().catch(e => console.log(`Erro ao iniciar v√≠deo de libras ${videoIndex}:`, e));
                  }, { once: true });
                }
              }, { once: true });
            }
          }
        }
        
        // Fun√ß√£o para mostrar apenas o v√≠deo de libras do target ativo
        function showActiveInterpreter(activeIndex) {
          const arVideo = videos[activeIndex];
          
          // S√≥ mostrar se o v√≠deo AR estiver tocando e pronto para reproduzir
          if (arVideo && !arVideo.paused && arVideo.readyState >= 3 && librasToggle.checked) {
            interpreterContainers.forEach((container, index) => {
              if (index === activeIndex) {
                container.style.display = 'block';
                container.style.opacity = '1';
              } else {
                container.style.opacity = '0';
                setTimeout(() => {
                  if (index !== activeIndex) {
                    container.style.display = 'none';
                  }
                }, 300);
              }
            });
          }
        }
        
        // Monitorar mudan√ßas nos v√≠deos AR individuais
        videos.forEach((video, index) => {
          video.addEventListener('play', () => {
            console.log(`V√≠deo AR ${index} iniciado`);
            activeTargetIndex = index; // Marcar target como ativo
            if (librasToggle.checked) {
              showActiveInterpreter(index);
              startInterpreterVideo(index); // Iniciar v√≠deo de libras automaticamente
            }
            syncInterpreterWithAR(index);
          });
          
          video.addEventListener('pause', () => {
            console.log(`V√≠deo AR ${index} pausado`);
            // Esconder v√≠deo de libras quando AR pausa
            if (librasToggle.checked) {
              interpreterContainers[index].style.opacity = '0';
              setTimeout(() => {
                interpreterContainers[index].style.display = 'none';
              }, 300);
            }
            syncInterpreterWithAR(index);
          });
          
          
          video.addEventListener('timeupdate', () => {
            syncInterpreterWithAR(index);
          });
          
          video.addEventListener('seeked', () => {
            syncInterpreterWithAR(index);
          });
          
          video.addEventListener('ended', () => {
            console.log(`V√≠deo AR ${index} finalizado`);
            activeTargetIndex = -1; // Marcar que nenhum target est√° ativo
            syncInterpreterWithAR(index);
            // Pausar e esconder o container de libras correspondente
            interpreterVideos[index].pause();
            interpreterContainers[index].style.opacity = '0';
            setTimeout(() => {
              interpreterContainers[index].style.display = 'none';
            }, 300);
          });
        });
      });
    </script>
  </body>
</html>
