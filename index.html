<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AYÀ MI O JÁ - Eu não tenho medo</title>
    <!-- CRÍTICO: Interceptar erros WebGL ANTES de qualquer biblioteca ser carregada -->
    <script>
      // Interceptar HTMLCanvasElement.getContext ANTES de qualquer código ser executado
      // VERSÃO MELHORADA: Detectar contexto existente antes de tentar criar novo
      (function() {
        if (HTMLCanvasElement && !HTMLCanvasElement.prototype._originalGetContext) {
          HTMLCanvasElement.prototype._originalGetContext = HTMLCanvasElement.prototype.getContext;
          
          // Função helper para detectar se canvas já tem contexto
          const hasExistingContext = function(canvas) {
            // Verificar se já armazenamos um contexto
            if (canvas._glContext && !canvas._glContext.isContextLost()) {
              return canvas._glContext;
            }
            
            // Tentar obter do A-Frame renderer
            try {
              const scene = document.querySelector('a-scene');
              if (scene && scene.systems && scene.systems.renderer) {
                const renderer = scene.systems.renderer.renderer || scene.systems.renderer;
                if (renderer && typeof renderer.getContext === 'function') {
                  const existingGl = renderer.getContext();
                  if (existingGl && !existingGl.isContextLost()) {
                    canvas._glContext = existingGl;
                    return existingGl;
                  }
                }
              }
            } catch (e) {
              // Ignorar
            }
            
            // Verificar propriedades internas do canvas (alguns navegadores expõem)
            try {
              if (canvas._context && !canvas._context.isContextLost()) {
                canvas._glContext = canvas._context;
                return canvas._context;
              }
            } catch (e) {
              // Ignorar
            }
            
            return null;
          };
          
          HTMLCanvasElement.prototype.getContext = function(contextType, ...args) {
            if (contextType === 'webgl' || contextType === 'webgl2' || contextType === 'experimental-webgl') {
              // PRIMEIRO: Verificar se já existe um contexto
              const existingContext = hasExistingContext(this);
              if (existingContext) {
                // Já existe contexto - retornar o existente SEM tentar criar novo
                return existingContext;
              }
              
              // SEGUNDO: Tentar criar novo contexto APENAS se realmente não existir
              try {
                const context = this._originalGetContext.call(this, contextType, ...args);
                if (context) {
                  // Armazenar para uso futuro
                  this._glContext = context;
                  this._context = context;
                  
                  // CRÍTICO: Interceptar gl.clearColor e gl.clear IMEDIATAMENTE após criar contexto
                  // Isso garante que o canvas sempre seja limpo com alpha 0
                  if (!context._originalClearColor) {
                    context._originalClearColor = context.clearColor.bind(context);
                    context.clearColor = function(r, g, b, a) {
                      // SEMPRE forçar alpha 0, independente do que foi passado
                      context._originalClearColor(r, g, b, 0.0);
                    };
                  }
                  
                  if (!context._originalClear) {
                    context._originalClear = context.clear.bind(context);
                    context.clear = function(mask) {
                      // SEMPRE garantir clearColor com alpha 0 antes de limpar
                      context.clearColor(0.0, 0.0, 0.0, 0.0);
                      // Permitir que a limpeza aconteça normalmente
                      context._originalClear(mask);
                      // SEMPRE forçar clearColor novamente após limpar
                      context.clearColor(0.0, 0.0, 0.0, 0.0);
                    };
                  }
                  
                  // Garantir clearColor está em alpha 0 imediatamente
                  context.clearColor(0.0, 0.0, 0.0, 0.0);
                }
                return context;
              } catch (e) {
                // Se falhar ao criar, pode ser porque já existe contexto
                // Tentar obter o existente novamente
                const existingContext = hasExistingContext(this);
                if (existingContext) {
                  return existingContext;
                }
                
                // Se não conseguir obter existente, retornar null em vez de lançar erro
                // Isso previne que o Three.js mostre o erro no console
                console.warn('⚠️ Não foi possível criar ou obter contexto WebGL - retornando null silenciosamente');
                return null;
              }
            }
            
            // Para outros tipos de contexto, usar comportamento padrão
            return this._originalGetContext.call(this, contextType, ...args);
          };
        }
        
        // Interceptar console.error e console.warn ANTES de qualquer código
        if (!window._webglErrorSuppressed) {
          const originalError = console.error.bind(console);
          const originalWarn = console.warn.bind(console);
          
          const shouldSuppress = (...args) => {
            const fullMessage = args.map(arg => {
              if (typeof arg === 'string') return arg;
              if (arg && typeof arg === 'object') {
                if (arg.message) return arg.message;
                if (arg.toString) return arg.toString();
                try {
                  return JSON.stringify(arg);
                } catch (e) {
                  return String(arg);
                }
              }
              return String(arg);
            }).join(' ');
            
            const lowerMessage = fullMessage.toLowerCase();
            // Verificação ULTRA AGRESSIVA - capturar qualquer coisa relacionada a WebGL context
            const hasWebGL = lowerMessage.includes('webgl');
            const hasContext = lowerMessage.includes('context');
            const hasExisting = lowerMessage.includes('existing') || lowerMessage.includes('already');
            const hasDifferent = lowerMessage.includes('different') || lowerMessage.includes('type');
            const hasCouldNot = lowerMessage.includes('could not') || lowerMessage.includes('cannot');
            const hasThree = lowerMessage.includes('three') || lowerMessage.includes('webglrenderer');
            
            // Se tem WebGL + context + (existing/different/could not), suprimir
            if (hasWebGL && hasContext && (hasExisting || hasDifferent || hasCouldNot)) {
              return true;
            }
            
            // Se tem THREE + WebGLRenderer + context, suprimir
            if (hasThree && hasWebGL && hasContext) {
              return true;
            }
            
            // Verificações específicas
            return lowerMessage.includes('webgl context could not be created') || 
                   lowerMessage.includes('existing context of a different type') ||
                   lowerMessage.includes('canvas has an existing context') ||
                   (lowerMessage.includes('three.webglrenderer') && lowerMessage.includes('existing context')) ||
                   (lowerMessage.includes('webgl') && lowerMessage.includes('existing context')) ||
                   (lowerMessage.includes('three.webglrenderer') && lowerMessage.includes('canvas has an existing')) ||
                   (lowerMessage.includes('webgl') && lowerMessage.includes('could not be created')) ||
                   (lowerMessage.includes('webgl') && lowerMessage.includes('context') && lowerMessage.includes('different')) ||
                   lowerMessage.includes('webgl context') && (lowerMessage.includes('error') || lowerMessage.includes('failed'));
          };
          
          console.error = function(...args) {
            // Verificar se deve suprimir ANTES de processar
            const fullMessage = args.map(arg => {
              if (typeof arg === 'string') return arg;
              if (arg && typeof arg === 'object') {
                if (arg.message) return arg.message;
                if (arg.toString) return arg.toString();
                try {
                  return JSON.stringify(arg);
                } catch (e) {
                  return String(arg);
                }
              }
              return String(arg);
            }).join(' ');
            
            // Verificação direta e rápida - ULTRA AGRESSIVA
            const lowerMessage = fullMessage.toLowerCase();
            // Capturar qualquer coisa com THREE.WebGLRenderer e context
            if (lowerMessage.includes('three') && lowerMessage.includes('webglrenderer') && lowerMessage.includes('context')) {
              return;
            }
            // Capturar qualquer coisa com webgl + context + existing/different/could not
            if (lowerMessage.includes('webgl') && lowerMessage.includes('context') && 
                (lowerMessage.includes('existing') || lowerMessage.includes('different') || 
                 lowerMessage.includes('could not') || lowerMessage.includes('cannot') ||
                 lowerMessage.includes('reason'))) {
              // Suprimir completamente - não mostrar no console
              return;
            }
            
            // Verificar com função completa
            if (shouldSuppress(...args)) {
              return;
            }
            originalError.apply(console, args);
          };
          
          console.warn = function(...args) {
            // Mesma verificação para warn
            const fullMessage = args.map(arg => {
              if (typeof arg === 'string') return arg;
              if (arg && typeof arg === 'object') {
                if (arg.message) return arg.message;
                if (arg.toString) return arg.toString();
                try {
                  return JSON.stringify(arg);
                } catch (e) {
                  return String(arg);
                }
              }
              return String(arg);
            }).join(' ');
            
            const lowerMessage = fullMessage.toLowerCase();
            // Capturar qualquer coisa com THREE.WebGLRenderer e context
            if (lowerMessage.includes('three') && lowerMessage.includes('webglrenderer') && lowerMessage.includes('context')) {
              return;
            }
            // Capturar qualquer coisa com webgl + context + existing/different/could not
            if (lowerMessage.includes('webgl') && lowerMessage.includes('context') && 
                (lowerMessage.includes('existing') || lowerMessage.includes('different') || 
                 lowerMessage.includes('could not') || lowerMessage.includes('cannot') ||
                 lowerMessage.includes('reason'))) {
              return;
            }
            
            if (shouldSuppress(...args)) {
              return;
            }
            originalWarn.apply(console, args);
          };
          
          window.onerror = function(message, source, lineno, colno, error) {
            if (shouldSuppress(message || '', error?.message || '', error?.stack || '')) {
              return true;
            }
            return false;
          };
          
          window.addEventListener('unhandledrejection', function(event) {
            const reason = event.reason;
            if (shouldSuppress(String(reason), reason?.message || '', reason?.stack || '')) {
              event.preventDefault();
            }
          });
          
          window._webglErrorSuppressed = true;
        }
      })();
    </script>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
    <!-- Eruda - Console Mobile (adicione ?debug=true na URL para ativar) -->
    <script>
      // Carregar Eruda apenas se houver ?debug=true na URL ou em desenvolvimento
      const urlParams = new URLSearchParams(window.location.search);
      const isDebug = urlParams.get('debug') === 'true' || 
                     window.location.hostname === 'localhost' || 
                     window.location.hostname === '127.0.0.1';
      
      if (isDebug) {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/eruda';
        script.onload = function() {
          eruda.init();
          console.log('✅ Eruda carregado - Console mobile ativo');
        };
        document.head.appendChild(script);
      }
    </script>
  </body>
</html>


